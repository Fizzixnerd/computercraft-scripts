-- -*- mode:lua -*-
os.loadAPI("log")
os.loadAPI("arraylib")
os.loadAPI("class")

-- A 'program' table is a 'command' table. The differentiation is
-- purely convention, at this point.  This may change in the future.
--
-- program := <command (command)>

-- A 'command' table contains:
--   * 'name' string naming the command.
--   * 'help' help table (optional).
--   * Exactly one of:
--      * 'handler' function which accepts a single array argument.
--      * 'commands' commands table with subcommands.
--
-- command :=
--   {name = <command_name (string)>,
--    handler = <handler (function)>,
--    [help = <help_table (help)>]}
--   |
--   {name = <command_name (string)>,
--    commands = <commands (commands)>,
--    [help = <help_table (help)>]}

-- A 'commands' table contains one or more 'command' tables.
-- 
-- commands :=
--   {<command_name> (string)> = <command (command)>,
--    [...]}

-- A 'help' table contains:
--   * 'usage' string containing the syntax of the command.
--   * 'summary' string sentence describing the command.
--   * 'long_help' array of strings containing zero or more sentences
--       describing the command/program in more detail.
--
-- help :=
--   {usage = <syntax (string)>,
--    summary = <sentence (string)>,
--    long_help = {[<sentence (string)>, [...]]}}

-- A 'CommandStack' table contains:
--   * 'next_frame' (optional) CommandStack table containing errors deeper in the
--       call stack.
--   * 'action' (optional) string with one of the following values:
--       "usage" -- prints the usage information for the failing command.
--       "summary" -- prints the summary information for the failing command.
--       "long_help" -- prints the full documentation for the failing command.
--   * 'command_name' string naming the command at this level of the call.
--   * 'msg' string explaining the error; empty if no useful information.
--
-- error :=
--   {command_name = <command_name (string)>,
--    msg = <error_message (string)>,
--    [next_frame = <next_frame (CommandStack)>,]
--    [action = "usage" | "summary" | "long_help"]}

local function nonNilAndOfType (obj, type_string)
   return (obj ~= nil) and (type(obj) == type_string)
end

local function nilOrOfType (obj, type_string)
   return (obj == nil) or (type(obj) == type_string)
end

function looksExactlyLike (obj, prototype)
   if (type(obj) ~= "table") then
      log.fatal("object obj given to looksExactlyLike isn't even a table.")
      return nil
   elseif (type(prototype) ~= table) then
      log.fatal("object prototype given to looksExactly isn't even a table.")
      return nil
   else
      for field, value in pairs(prototype) do
	 if (not nonNilAndOfType(obj[field], type(value))) then
	    return false
	 end
      end
   end
end
   
   
Help = class.define(function (obj, usage, summary, long_help)
		       obj.usage = usage or ""
		       obj.summary = summary or ""
		       obj.long_help = long_help or {}
		       return obj
		    end
)

Command = class.define(function (obj, name, commands_or_handler, help)
			  obj.name = name or ""
			  obj.help = help or Help()
			  if (type(commands_or_handler) == "table") then
			     obj.handler = nil
			     obj.commands = commands_or_handler
			  elseif (type(commands_or_handler) == "function") then
			     obj.handler = commands_or_handler
			     obj.commands = nil
			  else
			     log.fatal("You made a command without a handler function or a commands table.")
			  end
			  return obj
		       end
)

Commands = class.define(function (obj, ...)
			   for name, command in pairs({...}) do
			      if (type(name) ~= "string") then
				 log.fatal("You made a commands table with a non-string name.")
				 return nil
			      elseif (type(command) ~= "table") then
				 log.fatal("You gave a command that isn't even a table.")
				 return nil
			      elseif (not (command.name and (command.handler or command.commands) and command.help)) then
				 log.fatal("You gave a command which lacks at least one of the required values.")
				 return nil
			      else
				 -- everything looks okay!
				 obj[name] = command
			      end
			   end
			   return obj
			end
)

CommandStack = class.define(function (obj, command, msg, next_frame, action)
			       if nonNilAndOfType(command, "table") then
				  log.fatal("You gave a command that isn't even a table.")
				  return nil
			       elseif (not (command.name and (command.handler or command.commands) and command.help)) then
				  log.fatal("You gave a command that lacks at least one of the required values.")
				  return nil
			       else
				  obj.command = command
			       end

			       if (msg and (type(msg) ~= "string")) or (msg == false) then
				  -- the "or msg == false" is needed in case false is given.
				  log.fatal("You gave a msg that isn't a string.")
				  return nil
			       else
				  obj.msg = msg or ""
			       end

			       if nonNilAndOfType(action, "function") then
				  log.fatal("You gave an action that isn't a function.")
				  return nil
			       else
				  obj.action = action or function(self) end
			       end

			       obj.next_frame = next_frame
			       return obj
			    end
)			  

function runProgram (program, args)
   -- Executes the table 'program' (structure described above) with the
   -- array of string arguments 'args'.
   log.notImplemented()
end

function runCommand (command, args)
   if (command.handler) then
      return CommandStack(command.name, "", command.handler(args), nil)
   elseif (command.commands) then
      if (#args < 1) then
	 local msg = string.format("Too few arguments; %q expects a subcommand.",
				   command.name)
	 local action = "usage"
	 return CommandStack(command.name, msg, nil, action)
      else
	 local subcommand = command.commands[args[1]]
	 if (subcommand) then
	    -- Run the subcommand with the rest of the arguments
	    return newError(command.name,
			    "",
			    runCommand(subcommand, arraylib.slice(args, 2)),
			    nil)
	 else
	    -- given subcommand does not exist.
	    local msg = string.format("Invalid command: %q.", args[1])
	    local action = "usage"
	    return newError(command.name, msg, nil, action)
	 end
      end
   else
      -- command is broken! It doesn't have a handler or a commands table.
      local msg = string.format("The %q command is broken; this is a programming error.  It must contain either a 'handler' function or a 'commands' table.",
				command.name)
      return newError(command.name, msg, nil, nil)
   end
   log.UNREACHABLE(command.name .. " runCommand")
end
